<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8">
<title>Pianissimo Controller</title>
<style>
/* ------------------------------------- */
/* ESTILOS DEL CONTROLADOR PIANISSIMO */
/* ------------------------------------- */
body { font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif; background: #f2f2f7; margin:0; padding:20px; display:flex; flex-direction:column; align-items:center; }
h1 { color:#111; margin-bottom:20px; font-weight:600; text-align:center; }
button { margin:10px; padding:12px 25px; font-size:16px; border-radius:14px; border:none; cursor:pointer; background:#007aff; color:white; transition:0.2s; }
button:hover{background:#005bb5;} button:disabled{background:#aaa; cursor:not-allowed;}
.panel {background:#fff; border-radius:20px; box-shadow:0 8px 20px rgba(0,0,0,0.08); padding:30px 20px; margin:10px 0; width:95%; max-width:480px; display:flex; flex-direction:column; align-items:center;}
.tabs{display:none; margin-bottom:20px; width:95%; max-width:480px; justify-content:center;}
.tab{padding:10px 20px; cursor:pointer; border-bottom:3px solid transparent; font-weight:500; transition:0.2s; border-radius:8px 8px 0 0; background:#e0e0e0; margin-right:5px;}
.tab.active{background:#fff; border-bottom:3px solid #007aff;}
/* PANELES DE CONTENIDO OCULTOS POR DEFECTO */
.panelContent{display:none; flex-direction:column; width:95%; max-width:480px; padding:30px 20px; background:#fff; border-radius:20px; box-shadow:0 8px 20px rgba(0,0,0,0.08);}
.panelContent.active{display:flex;}

input[type=range]{width:100%; margin:6px 0 20px 0;}
.colorControl{display:flex; flex-direction:column; width:100%; margin-bottom:15px;}
.colorInputContainer{display:flex; align-items:center;}
.colorInputContainer label{flex-grow:1;}
.colorPickerBtn {width: 45px; height: 30px; border-radius: 10px; border: 1px solid #ccc; background: white; cursor: pointer; display: flex; align-items: center; justify-content: center; margin-left: 10px;}
.colorIndicator{width:45px; height:30px; border-radius:10px; border:1px solid #ccc; margin-left:10px; box-shadow:inset 0 1px 2px rgba(0,0,0,0.15);}
.colorPalette { display: none; flex-wrap: wrap; justify-content: space-between; padding: 10px 0; border-top: 1px solid #eee; margin-top: 10px; }
.colorSwatch { width: 30px; height: 30px; border-radius: 5px; margin: 3px; cursor: pointer; border: 2px solid transparent; transition: border-color 0.1s; }
.colorSwatch:hover { border-color: #007aff; }
#status,#barridoStatus{margin-top:10px; font-weight:500; text-align:center;}
#piano{position:relative; width:100%; height:200px; user-select:none;}
.whiteKey,.blackKey{position:absolute; border:1px solid #000; box-sizing:border-box; border-radius:4px; touch-action:none;}
.whiteKey{background:#fff; z-index:1;} .whiteKey.active{background:#cce6ff;}
.blackKey{background:#000; z-index:2; height:60%;} .blackKey.active{background:#555;}
@media(max-width:500px){#piano{height:150px;}}

/* ------------------------------------- */
/* ESTILOS DEL REPRODUCTOR MIDI (TOPE DE GAMA) */
/* ------------------------------------- */
.midi-player-container { width:100%; display:flex; flex-direction:column; align-items:center; }
.upload-section { margin-bottom:25px; width:100%; }
.file-input-wrapper { position:relative; display:block; margin-bottom:15px; text-align:center;}
.file-input { position:absolute; opacity:0; width:100%; height:100%; cursor:pointer; left:0; top:0; }
.file-button { background:#34c759; color:white; padding:12px 30px; border-radius:12px; font-size:16px; font-weight:600; width:100%; max-width:250px; }
.file-button:hover { background:#28a745; }
.song-info { margin-bottom:25px; opacity:0; transition:opacity 0.5s ease; color:#333; text-align:center; width:100%; border:1px solid #eee; padding:15px; border-radius:12px; background:#f9f9f9;}
.song-info.show { opacity:1; }
.song-title { font-size:18px; font-weight:700; margin-bottom:5px; color:#111; overflow:hidden; white-space:nowrap; text-overflow:ellipsis; }
.song-duration { color:#666; font-size:14px; }
.player-controls { display:flex; justify-content:center; align-items:center; gap:20px; margin:20px 0; opacity:0; transition:opacity 0.5s ease; }
.player-controls.show { opacity:1; }
.control-btn { 
    background:#007aff; border:none; border-radius:50%; color:white; cursor:pointer; transition:all 0.3s ease; box-shadow:0 4px 10px rgba(0,0,0,0.15); 
    /* Alineación de iconos centrada */
    display: flex;
    align-items: center;
    justify-content: center;
}
.control-btn:hover { background:#005bb5; transform:scale(1.05); }
.play-btn { width:60px; height:60px; font-size:24px; }
.secondary-btn { width:45px; height:45px; font-size:18px; }

/* Control de Velocidad con Botones */
#midiSpeedControl { margin:15px 0; opacity:0; transition:opacity 0.5s ease; width:100%; display:flex; flex-direction:column; align-items:center;}
#midiSpeedControl.show { opacity:1; }
.speed-label { display:block; margin-bottom:10px; font-size:14px; color:#333; font-weight:600; width:100%;}
.speed-value { color:#007aff; font-weight:bold; font-size:16px; float:right;}
.speed-button-group {
    display: flex;
    justify-content: space-between;
    width: 100%;
    margin-top: 5px;
    background: #f0f0f5; /* Light background for the group */
    border-radius: 12px;
    padding: 5px;
    box-shadow: inset 0 1px 3px rgba(0,0,0,0.1);
}
.speed-btn {
    flex-grow: 1;
    padding: 8px 0;
    margin: 0 2px;
    border: none;
    border-radius: 8px;
    cursor: pointer;
    font-weight: 600;
    color: #666;
    background: transparent;
    transition: background 0.2s, color 0.2s;
    font-size: 14px;
}
.speed-btn.active {
    background: #007aff;
    color: white;
    box-shadow: 0 3px 8px rgba(0, 122, 255, 0.4);
}
.speed-btn:hover:not(.active) {
    background: #e0e0e0;
}

.loading { display:none; margin:15px 0; color:#007aff; }
.loading.show { display:block; }
.spinner { border:3px solid #f3f3f3; border-radius:50%; border-top:3px solid #007aff; width:20px; height:20px; animation:spin 1s linear infinite; margin:0 auto; }
@keyframes spin { 0%{transform:rotate(0deg);} 100%{transform:rotate(360deg);} }
.error-message { color:#ff3b30; background:rgba(255,59,48,0.1); padding:10px; border-radius:10px; margin:10px 0; border:1px solid rgba(255,59,48,0.3); display:none; }
.error-message.show { display:block; }
#channelControls { margin-top:20px; display:flex; flex-wrap:wrap; justify-content:center; gap:15px; border-top:1px solid #eee; padding-top:15px; }
#channelControls label { font-size:14px; cursor:pointer; display:flex; flex-direction:column; align-items:center; color:#333; font-weight:500;}
#channelControls input { margin-bottom:5px; cursor:pointer; transform:scale(1.2);}
.channel-indicator { width:10px; height:10px; border-radius:50%; background:#999; margin-top:4px; transition: all 0.2s ease, box-shadow 0.3s ease; opacity:0.4; }
.channel-indicator.active { background:#ff9500; box-shadow:0 0 5px #ff9500; opacity:1; }

</style>
</head>
<body>

<h1>Pianissimo Controller</h1>

<div class="panel" id="connectPanel">
  <button id="connect">Conectar Pianissimo</button>
  <button id="disconnect" disabled>Desconectar</button>
  <p id="status">Estado: Desconectado</p>
</div>

<div class="tabs" id="tabs">
  <div class="tab active" data-target="controlsPanel">Controles</div>
  <div class="tab" data-target="pianoPanel">Piano</div>
  <div class="tab" data-target="midiPanel">Reproductor MIDI</div>
</div>

<div class="panelContent" id="controlsPanel">
  <label>Brillo: <span id="brightnessVal">128</span></label>
  <input type="range" id="brightness" min="0" max="255" value="128">
  <div class="colorControl">
    <div class="colorInputContainer">
      <label>Color teclas blancas:</label>
      <div id="whiteColorBtn" class="colorPickerBtn"><span id="whiteIndicator" class="colorIndicator" style="background:#ffffff; margin:0; border:none; box-shadow:none;"></span></div>
    </div>
    <div id="whiteColorPalette" class="colorPalette"></div>
  </div>
  <div class="colorControl">
    <div class="colorInputContainer">
      <label>Color teclas negras:</label>
      <div id="blackColorBtn" class="colorPickerBtn"><span id="blackIndicator" class="colorIndicator" style="background:#000000; margin:0; border:none; box-shadow:none;"></span></div>
    </div>
    <div id="blackColorPalette" class="colorPalette"></div>
  </div>
  <label>Velocidad lluvia (ms): <span id="speedVal">50</span></label>
  <input type="range" id="speed" min="30" max="500" value="50">
  <div style="display:flex; justify-content:space-around; width:100%;">
    <button id="test">Probar Barrido (10 notas)</button>
    <button id="allnoteoff" style="background:#ff3b30;">All Notes OFF</button>
  </div>
  <p id="barridoStatus"></p>
</div>

<div class="panelContent" id="pianoPanel">
  <div id="piano"></div>
</div>

<div class="panelContent" id="midiPanel">
  <div class="midi-player-container">
    <div class="upload-section">
      <div class="file-input-wrapper">
        <input type="file" id="midiFile" class="file-input" accept=".mid,.midi" />
        <button class="file-button">Cargar archivo MIDI</button>
      </div>
      <div class="error-message" id="errorMessage"></div>
    </div>
    <div class="loading" id="midiLoading"><div class="spinner"></div><p style="margin-top:10px;">Cargando archivo...</p></div>
    <div class="song-info" id="songInfo">
      <div class="song-title" id="songTitle">Nombre del archivo</div>
      <div class="song-duration" id="songDuration">Duración total: N/A</div>
    </div>

    <div class="player-controls" id="playerControls">
      <button class="control-btn play-btn" id="midiPlayBtn" title="Play/Pause">▶</button>
      <button class="control-btn secondary-btn" id="midiStopBtn" title="Stop">⏹</button>
    </div>
    <div class="speed-control" id="midiSpeedControl">
      <label class="speed-label" style="text-align:center;">Velocidad actual: <span class="speed-value" id="midiSpeedValue">1.00x</span></label>
      <div class="speed-button-group" id="speedButtonGroup">
        <button class="speed-btn" data-speed="0.25">0.25x</button>
        <button class="speed-btn" data-speed="0.5">0.5x</button>
        <button class="speed-btn active" data-speed="1">1.00x</button>
        <button class="speed-btn" data-speed="2">2.00x</button>
      </div>
    </div>
    <div id="channelControls"></div>
  </div>
</div>

<script>
// =========================================================================
// VARIABLES GLOBALES Y UTILIDADES BLUETOOTH MIDI (PIANISSIMO)
// =========================================================================
const midiServiceUUID='03b80e5a-ede8-4b33-a751-6ce34ec4c700';
const midiCharUUID='7772e5db-3868-4112-a1a9-f2669d106bf3';
let device,midiChar;

// Elementos del Controlador
const connectBtn=document.getElementById('connect');
const disconnectBtn=document.getElementById('disconnect');
const statusEl=document.getElementById('status');
const tabs=document.getElementById('tabs');
const tabButtons=document.querySelectorAll('.tab');
const panels={'controlsPanel':document.getElementById('controlsPanel'),'pianoPanel':document.getElementById('pianoPanel'),'midiPanel':document.getElementById('midiPanel')};
const controlsPanel=document.getElementById('controlsPanel');
const pianoPanel=document.getElementById('pianoPanel');
const midiPanel=document.getElementById('midiPanel');

const brightnessSlider=document.getElementById('brightness');
const speedSlider=document.getElementById('speed');
const brightnessVal=document.getElementById('brightnessVal');
const speedVal=document.getElementById('speedVal');
const whiteColorBtn = document.getElementById('whiteColorBtn');
const blackColorBtn = document.getElementById('blackColorBtn');
const whiteIndicator = document.getElementById('whiteIndicator');
const blackIndicator = document.getElementById('blackIndicator');
const barridoBtn=document.getElementById('test');
const allNoteOffBtn=document.getElementById('allnoteoff');
const barridoStatus=document.getElementById('barridoStatus');

// Lista de controles interactivos para deshabilitar
const allControls = [brightnessSlider, speedSlider, whiteColorBtn, blackColorBtn, connectBtn, disconnectBtn, barridoBtn, allNoteOffBtn];

// Auxiliar para RGB
function hexToRgb(hex){const bigint=parseInt(hex.slice(1),16);return {r:(bigint>>16)&255,g:(bigint>>8)&255,b:bigint&255};}

/**
 * Función base para escribir mensajes MIDI. Controla la serialización.
 * @param {number[]} data - Array de bytes del mensaje MIDI (o SysEx)
 * @param {boolean} needsDelay - True si es un SysEx (necesita 10ms), False para notas MIDI.
 */
async function writeMidi(data, needsDelay = false) {
    if(!midiChar) return;
    try {
        await midiChar.writeValue(new Uint8Array(data));
        // Delay de 10ms solo si es necesario (para SysEx)
        if (needsDelay) {
            await new Promise(r => setTimeout(r, 10)); 
        }
    } catch(err) {
        console.error("Error writing MIDI:", err);
    }
}

/**
 * Función para enviar mensajes SysEx (serializados) - Mantiene el delay de 10ms
 * @param {number} cmd - Comando SysEx
 * @param {number[]} payload - Datos del payload
 */
async function sendSysEx(cmd,payload){
    if(!midiChar)return;
    // Usa writeMidi con needsDelay = true
    await writeMidi([0xF0,0x7D,cmd,...payload,0xF7], true);
}

// Funciones Note ON/OFF. Usa la lógica de await writeValue sin delay adicional.
const midiQueue = [];
let processingQueue = false;
let stopQueue = false;

function enqueueMidi(data) {
    midiQueue.push(data);
    processMidiQueue();
}

async function processMidiQueue() {
    if (processingQueue || !midiChar) return;
    processingQueue = true;
    stopQueue = false;
    while (midiQueue.length > 0) {
        if (stopQueue) break;
        const data = midiQueue.shift();
        try {
            await midiChar.writeValue(new Uint8Array(data));
            await new Promise(r => setTimeout(r, 2));
        } catch(err) {
            console.error('Error enviando MIDI:', err);
        }
    }
    processingQueue = false;
}

function noteOn(note) {
    enqueueMidi([0x90, note, 127]);
}

function noteOff(note) {
    enqueueMidi([0x80, note, 0]);
}

// Cancelar cola inmediatamente
function stopMidiQueue() {
    midiQueue.length = 0;
    stopQueue = true;
}




// =========================================================================
// LÓGICA DE CONEXIÓN Y CONFIGURACIÓN INICIAL
// =========================================================================

// Función de inicialización de configuraciones al conectar (Serializada)
async function initializeSettings() {
    const settings = [
        { cmd: 0x01, val: 128, indicator: brightnessSlider, display: brightnessVal, hex: undefined }, 
        { cmd: 0x04, val: 50, indicator: speedSlider, display: speedVal, hex: undefined }, 
        { cmd: 0x02, val: [0, 0, 255], hex: '#0000FF', indicator: whiteIndicator }, 
        { cmd: 0x03, val: [128, 0, 128], hex: '#800080', indicator: blackIndicator }  
    ];

    for (const s of settings) {
        if (s.cmd === 0x01 || s.cmd === 0x04) {
            if (s.cmd === 0x04) {
                await sendSysEx(s.cmd, [(s.val >> 7) & 0x7F, s.val & 0x7F]);
            } else {
                await sendSysEx(s.cmd, [s.val]);
            }
            s.indicator.value = s.val;
            s.display.textContent = s.val;

        } else if (s.cmd === 0x02 || s.cmd === 0x03) {
            await sendSysEx(s.cmd, s.val);
            s.indicator.style.background = s.hex;
        }
    }
}

// Evento de conexión
connectBtn.addEventListener('click',async()=>{
  try{
    statusEl.textContent='Buscando Pianissimo...';
    device=await navigator.bluetooth.requestDevice({filters:[{name:'Pianissimo',services:[midiServiceUUID]}]});
    device.addEventListener('gattserverdisconnected',()=>{
      statusEl.textContent='Desconectado';
      disconnectBtn.disabled=true;
      tabs.style.display='none'; 
      controlsPanel.classList.remove('active'); // Ocultar paneles
      pianoPanel.classList.remove('active');
      midiPanel.classList.remove('active');
    });
    statusEl.textContent='Conectando...'; 
    const server=await device.gatt.connect();
    const service=await server.getPrimaryService(midiServiceUUID);
    midiChar=await service.getCharacteristic(midiCharUUID);
    await midiChar.startNotifications();
    midiChar.addEventListener('characteristicvaluechanged',e=>console.log('MIDI',new Uint8Array(e.target.value.buffer)));
    
    // ESPERA DE 4 SEGUNDOS (AJUSTADO)
    await new Promise(r => setTimeout(r, 4000));
    
    // ENVIAR CONFIGURACIONES ESTÁNDAR 
    await initializeSettings(); 
    
    statusEl.textContent='Conectado';
    disconnectBtn.disabled=false;
    tabs.style.display='flex'; 
    controlsPanel.classList.add('active'); // Mostrar panel de controles por defecto
    createPiano(); 
    player.onConnected(); 

  }catch(err){
    console.error(err);
    statusEl.textContent='Error: '+err;
    tabs.style.display='none'; 
    controlsPanel.classList.remove('active'); 
    pianoPanel.classList.remove('active');
    midiPanel.classList.remove('active');
  }
});

disconnectBtn.addEventListener('click',()=>{
  if(device?.gatt.connected) device.gatt.disconnect();
  tabs.style.display='none'; 
  player.onDisconnected(); 
});


// =========================================================================
// LÓGICA DE PESTAÑAS Y CONTROLES DEL PIANISSIMO
// =========================================================================

// pestañas
tabButtons.forEach(tab=>{
  tab.addEventListener('click',()=>{
    tabButtons.forEach(t=>t.classList.remove('active'));
    tab.classList.add('active');
    Object.values(panels).forEach(p=>p.classList.remove('active'));
    panels[tab.dataset.target].classList.add('active');
    if(tab.dataset.target === 'pianoPanel') createPiano();
    if(tab.dataset.target !== 'midiPanel' && player.isPlaying) player.pause();
  });
});

// Controladores
brightnessSlider.addEventListener('input',()=>{brightnessVal.textContent=brightnessSlider.value;sendSysEx(0x01,[parseInt(brightnessSlider.value)]);});
speedSlider.addEventListener('input',async ()=>{speedVal.textContent=speedSlider.value;await sendSysEx(0x04,[(parseInt(speedSlider.value)>>7)&0x7F,parseInt(speedSlider.value)&0x7F]);});

// Paleta de colores (sin cambios)
const basicColors=[
  '#F5F5F5', '#FFFFFF', '#FF0000', '#00FF00', '#0000FF', '#FFFF00', '#00FFFF', '#FF00FF',
  '#800000', '#008000', '#000080', '#808000', '#008080', '#800080', '#808080', '#C0C0C0',
  '#FF8000', '#80FF00', '#00FF80', '#0080FF', '#8000FF', '#FF0080', '#FFD700', '#ADFF2F',
  '#4682B4', '#DA70D6', '#FFA07A', '#F08080', '#20B2AA', '#7FFF00', '#D2B48C', '#F0F8FF'
];

function setupColorPicker(buttonId, indicatorId, paletteId, sysexCmd) {
  const button = document.getElementById(buttonId);
  const indicator = document.getElementById(indicatorId);
  const palette = document.getElementById(paletteId);

  basicColors.forEach(hex => {
    const swatch = document.createElement('div');
    swatch.className = 'colorSwatch';
    swatch.style.backgroundColor = hex;
    swatch.dataset.hex = hex;
    swatch.addEventListener('click', async () => {
      const rgb = hexToRgb(hex);
      await sendSysEx(sysexCmd, [rgb.r, rgb.g, rgb.b]);
      indicator.style.background = hex;
      palette.style.display = 'none'; 
    });
    palette.appendChild(swatch);
  });

  button.addEventListener('click', (e) => {
    e.stopPropagation(); 
    palette.style.display = palette.style.display === 'flex' ? 'none' : 'flex';
  });

  document.addEventListener('click', () => { palette.style.display = 'none'; });
  palette.addEventListener('click', (e) => { e.stopPropagation(); });
}

setupColorPicker('whiteColorBtn', 'whiteIndicator', 'whiteColorPalette', 0x02);
setupColorPicker('blackColorBtn', 'blackIndicator', 'blackColorPalette', 0x03);

// Barrido de prueba (CORREGIDO para usar la lógica asíncrona de noteOn/Off)
async function playNote(note,duration){
  if(!midiChar) return;
  // noteOn y noteOff son ahora funciones asíncronas con await
  noteOn(note);
setTimeout(() => noteOff(note), duration);

}
barridoBtn.addEventListener('click', async () => {
    if (!midiChar) return;
    player.stopAndReset();
    barridoStatus.textContent = 'Barrido en curso...';
    allControls.forEach(b => b.disabled = true);

    const notes = [60, 61, 62, 63, 64, 65, 66, 67, 68, 69]; 
    const duration = 100; // ms

    for (const n of notes) {
        noteOn(n);
        await new Promise(r => setTimeout(r, duration));
        noteOff(n);
    }

    allControls.forEach(b => b.disabled = false);
    barridoStatus.textContent = 'Barrido completado';
});

// All Notes OFF
allNoteOffBtn.addEventListener('click', () => {
  if (!midiChar) return;
  writeMidi([0xB0, 0x7B, 0x00], false); 
  
  activeNotes.forEach((el, note) => { el.classList.remove('active'); });
  activeNotes.clear();
  barridoStatus.textContent = 'All Notes OFF enviado';
});


// Lógica del Piano (sin cambios en la interacción)
const pianoDiv=document.getElementById('piano');
let activeNotes=new Map(); 
let isMouseDown = false;
let lastElement = null; 

function createPiano(){
  pianoDiv.innerHTML='';
  const whiteNotes=[60,62,64,65,67,69,71,72,74,76,77,79,81,83]; 
  const blackNotes=[61,63,66,68,70,73,75,78,80,82]; 
  const whiteWidth=100/whiteNotes.length;

  whiteNotes.forEach((n,i)=>{
    const key=document.createElement('div');
    key.className='whiteKey';
    key.dataset.note=n;
    key.style.left=`${i*whiteWidth}%`;
    key.style.width=`${whiteWidth}%`;
    key.style.height='100%';
    pianoDiv.appendChild(key);
  });

  const blackOffsets=[0,1,3,4,5,7,8,10,11,12];
  blackNotes.forEach((n,i)=>{
    const key=document.createElement('div');
    key.className='blackKey';
    key.dataset.note=n;
    const w=whiteWidth*0.6;
    key.style.width=w+'%';
    key.style.left=`${blackOffsets[i]*whiteWidth + whiteWidth - w/2}%`;
    key.style.height='60%';
    pianoDiv.appendChild(key);
  });
}

function pressKey(el){
    if(!el || !el.dataset.note) return;
    const note=+el.dataset.note;
    if(!activeNotes.has(note)){
        el.classList.add('active');
        activeNotes.set(note, el); 
        noteOn(note); 
    }
}
function releaseKey(note){
    if(activeNotes.has(note)){
        const el = activeNotes.get(note);
        noteOff(note); 
        el.classList.remove('active');
        activeNotes.delete(note);
    }
}

// Eventos de ratón para arrastrar
pianoDiv.addEventListener('mousedown',e=>{
    if(e.target.dataset.note) {
      isMouseDown = true;
      lastElement = e.target;
      pressKey(e.target);
    }
});
document.addEventListener('mouseup',()=>{
    if(isMouseDown){
        activeNotes.forEach((el, note) => releaseKey(note));
        isMouseDown = false;
        lastElement = null;
    }
});
pianoDiv.addEventListener('mousemove',e=>{
    if(!isMouseDown) return;
    const currentElement = e.target;
    if (currentElement !== lastElement) {
        if(lastElement?.dataset.note && activeNotes.has(+lastElement.dataset.note)){
            releaseKey(+lastElement.dataset.note);
        }
        if(currentElement?.dataset.note){
            pressKey(currentElement);
        }
        lastElement = currentElement;
    }
});
pianoDiv.addEventListener('mouseleave',()=>{
    if(isMouseDown){
        activeNotes.forEach((el, note) => releaseKey(note));
        lastElement = null;
    }
});

// Eventos táctiles
pianoDiv.addEventListener('touchstart',e=>{
    e.preventDefault();
    Array.from(e.changedTouches).forEach(t=>{
        const el=document.elementFromPoint(t.clientX,t.clientY);
        pressKey(el);
    });
});
pianoDiv.addEventListener('touchend',e=>{
    e.preventDefault();
    Array.from(e.changedTouches).forEach(t=>{
        const el=document.elementFromPoint(t.clientX,t.clientY);
        if(el?.dataset.note){
            const note = +el.dataset.note;
            releaseKey(note);
        }
    });
});
pianoDiv.addEventListener('touchcancel',e=>{
    activeNotes.forEach((el, note) => releaseKey(note));
});


// =========================================================================
// CLASE MIDI PLAYER (SERIALIZACIÓN Y OPTIMIZACIÓN DE TIMING)
// =========================================================================

class MIDIPlayer {
constructor(){
this.currentMidi=null;
this.isPlaying=false;
this.playbackSpeed=1;
this.stopPlayback=false; 
this.channels=new Set();
this.activeChannels={};
this.indicators={};
this.isDeviceConnected=false; 

this.initializeElements();
this.setupEventListeners();
}

initializeElements(){
this.fileInput=document.getElementById('midiFile');
this.playBtn=document.getElementById('midiPlayBtn');
this.stopBtn=document.getElementById('midiStopBtn');
this.songTitle=document.getElementById('songTitle');
this.songDuration=document.getElementById('songDuration');
this.speedValue=document.getElementById('midiSpeedValue');
this.loading=document.getElementById('midiLoading');
this.errorMessage=document.getElementById('errorMessage');
this.songInfo=document.getElementById('songInfo');
this.controls=document.getElementById('playerControls');
this.speedControl=document.getElementById('midiSpeedControl');
this.channelControls=document.getElementById('channelControls');
this.speedButtons=document.querySelectorAll('.speed-btn'); // Novedad: Botones
}

setupEventListeners(){
this.fileInput.addEventListener('change',e=>this.loadMIDI(e));
this.playBtn.addEventListener('click',()=>this.togglePlay());
this.stopBtn.addEventListener('click',()=>this.stopAndReset());

// Novedad: Escuchador para los botones de velocidad
this.speedButtons.forEach(button => {
    button.addEventListener('click', e => {
        const speed = parseFloat(e.target.dataset.speed);
        this.changeSpeed(speed);
    });
});

document.addEventListener('keydown',e=>{if(e.code==='Space'&&this.currentMidi){e.preventDefault();this.togglePlay();}});
}

onConnected(){this.isDeviceConnected=true;}
onDisconnected(){this.isDeviceConnected=false; this.stopAndReset();}

showError(msg){this.errorMessage.textContent=msg;this.errorMessage.classList.add('show');setTimeout(()=>this.errorMessage.classList.remove('show'),8000);}
hideError(){this.errorMessage.classList.remove('show');}

async loadMIDI(event){
const file=event.target.files[0];
if(!file)return;
this.hideError();
this.loading.classList.add('show');

// resetear estado
this.channels.clear();
this.activeChannels={};
this.channelControls.innerHTML='';
this.indicators={};

this.stopAndReset(); 

try{
const arrayBuffer=await file.arrayBuffer();
this.currentMidi=await this.parseMIDI(arrayBuffer,file.name);
this.channels.forEach(ch=>this.activeChannels[ch]=true);
this.updateUI(file.name);
this.updateChannelControls();
this.loading.classList.remove('show');
}catch(err){
console.error('Error cargando MIDI:',err);
this.showError('Error al cargar el archivo MIDI. (Asegúrate que no esté corrupto)');
this.loading.classList.remove('show');
}
}

// Lógica de parsing MIDI (Solo Note On/Off)
async parseMIDI(arrayBuffer,fileName){
const dataView=new DataView(arrayBuffer);
let offset=0;
const header=String.fromCharCode(dataView.getUint8(0),dataView.getUint8(1),dataView.getUint8(2),dataView.getUint8(3));
if(header!=='MThd') throw new Error(`Header inválido: ${header}`);
offset+=4;
const headerLength=dataView.getUint32(offset); offset+=4;
const format=dataView.getUint16(offset); offset+=2;
const trackCount=dataView.getUint16(offset); offset+=2;
const timeDivision=dataView.getUint16(offset); offset+=2;

const notes=[];
const activeNotes=new Map();

for(let t=0;t<trackCount;t++){
const trackHeader=String.fromCharCode(dataView.getUint8(offset),dataView.getUint8(offset+1),dataView.getUint8(offset+2),dataView.getUint8(offset+3));
if(trackHeader!=='MTrk') break;
offset+=4;
const trackLength=dataView.getUint32(offset); offset+=4;
const trackEnd=offset+trackLength;

let currentTime=0,runningStatus=0;

while(offset<trackEnd && offset<arrayBuffer.byteLength){
let deltaTime=0,byte;
do{byte=dataView.getUint8(offset++); deltaTime=(deltaTime<<7)|(byte&0x7F);}while(byte&0x80);
currentTime+=deltaTime;
if(offset>=arrayBuffer.byteLength) break;

let statusByte=dataView.getUint8(offset);
if(statusByte<0x80){statusByte=runningStatus; offset--;}else{runningStatus=statusByte;}
offset++;
const eventType=statusByte&0xF0;
const channel=statusByte&0x0F;

if(eventType===0x90||eventType===0x80){ 
if(offset+1>=arrayBuffer.byteLength) break;
const noteNumber=dataView.getUint8(offset++);
const velocity=dataView.getUint8(offset++);
const timeSec=currentTime/timeDivision * (60 / 120); 

if(eventType===0x90 && velocity>0){
const key=`${noteNumber}-${channel}`;
activeNotes.set(key,{note:this.midiNoteToNoteName(noteNumber),startTime:timeSec,velocity:velocity/127,noteNumber,channel});
this.channels.add(channel);
}else{
const key=`${noteNumber}-${channel}`;
const n=activeNotes.get(key);
if(n){
const duration=Math.max(timeSec-n.startTime,0.05);
notes.push({time:n.startTime,note:n.note,duration,velocity:n.velocity,channel,noteNumber});
activeNotes.delete(key);
}
}
}else if(eventType===0xC0||eventType===0xD0){if(offset<arrayBuffer.byteLength) offset++;} 
else if(eventType===0xA0||eventType===0xB0||eventType===0xE0){if(offset+1<arrayBuffer.byteLength) offset+=2;} 
else if(statusByte===0xFF){const metaType=dataView.getUint8(offset++);let length=0; do{byte=dataView.getUint8(offset++); length=(length<<7)|(byte&0x7F);}while(byte&0x80); offset+=length;} 
else if(statusByte>=0xF0){if(statusByte===0xF0) while(offset<arrayBuffer.byteLength && dataView.getUint8(offset++)!==0xF7);} 
}
}

activeNotes.forEach(n=>notes.push({time:n.startTime,note:n.note,duration:0.5,velocity:n.velocity,channel:n.channel,noteNumber:n.noteNumber}));
notes.sort((a,b)=>a.time-b.time);
const duration=notes.length>0?Math.max(...notes.map(n=>n.time+n.duration)):1;
return{name:fileName,notes,duration};
}

midiNoteToNoteName(n){const notes=['C','C#','D','D#','E','F','F#','G','G#','A','A#','B'];const o=Math.floor(n/12)-1;return notes[n%12]+o;}

updateUI(fileName){
    this.songTitle.textContent=fileName;
    this.songInfo.classList.add('show');
    this.controls.classList.add('show');
    this.speedControl.classList.add('show');
    
    // Al cargar un archivo, la velocidad por defecto es 1.00x
    this.changeSpeed(1);

    this.songDuration.textContent = 'Duración total: ' + this.formatTime(this.currentMidi.duration / this.playbackSpeed); 
}

updateChannelControls(){this.channelControls.innerHTML='';this.channels.forEach(ch=>{
const label=document.createElement('label');
const checkbox=document.createElement('input'); checkbox.type='checkbox'; checkbox.checked=this.activeChannels[ch]; checkbox.addEventListener('change',e=>this.activeChannels[ch]=e.target.checked);
const text=document.createTextNode(`Canal ${ch}`);
const indicator=document.createElement('span'); indicator.classList.add('channel-indicator'); indicator.dataset.channel=ch; this.indicators[ch]=indicator;
label.appendChild(checkbox); label.appendChild(text); label.appendChild(indicator); this.channelControls.appendChild(label);
});}

togglePlay(){this.isPlaying?this.pause():this.play();}

async play(){
if(!this.currentMidi) return;
if(!this.isDeviceConnected) return this.showError('¡Conéctate al Pianissimo primero!');

this.isPlaying=true;
this.playBtn.textContent='⏸';
this.stopPlayback=false;
this.schedulePlayback();
}

pause(){
this.isPlaying=false; 
this.stopPlayback=true; 
this.playBtn.textContent='▶'; 
// Enviar All Notes OFF al pausar.
writeMidi([0xB0, 0x7B, 0x00], false); 
}

stopAndReset(){
this.pause(); 
this.stopPlayback=true;
this.isPlaying=false; 
this.playBtn.textContent='▶';
stopMidiQueue(); // detiene todo lo que estaba en la cola 
}

// Función de cambio de velocidad (Actualizada para botones)
changeSpeed(newSpeed){
    this.playbackSpeed = newSpeed;
    this.speedValue.textContent = this.playbackSpeed.toFixed(2)+'x'; 

    if(this.currentMidi){
        this.songDuration.textContent = 'Duración total: ' + this.formatTime(this.currentMidi.duration / this.playbackSpeed);
    }

    // Actualizar el estado activo de los botones de velocidad
    this.speedButtons.forEach(btn => {
        if (parseFloat(btn.dataset.speed) === newSpeed) {
            btn.classList.add('active');
        } else {
            btn.classList.remove('active');
        }
    });
}

formatTime(s){const m=Math.floor(s/60),sec=Math.floor(s%60); return `${String(m).padStart(2,'0')}:${String(sec).padStart(2,'0')}`;}

// FUNCIÓN CLAVE: Reproducción secuencial y cronometrada.
async schedulePlayback() {
    let lastTime = 0;

    for (const note of this.currentMidi.notes) {
        if (this.stopPlayback) return;
        
        const delayMs = (note.time - lastTime) * 1000 / this.playbackSpeed;
await new Promise(r => setTimeout(r, delayMs));
lastTime = note.time;


        if (this.activeChannels[note.channel]) {
            // Note ON (El await aquí es la serialización de tiempo)
            noteOn(note.noteNumber);


            // Actualizar indicador de canal
            const ind = this.indicators[note.channel];
            if (ind) {
                ind.classList.add('active');
                
                // Programar Note OFF (El setTimeout escala con la duración y la velocidad)
                setTimeout(async () => {
                    // Note OFF (El await aquí es la serialización de tiempo)
                    noteOff(note.noteNumber);
                    if (ind) ind.classList.remove('active');
                }, note.duration * 1000 / this.playbackSpeed);
            }
        }
    }
    
    // Reproducción finalizada
    if (!this.stopPlayback) {
        this.stopAndReset();
        this.playBtn.textContent = '▶';
    }
}
}
const player=new MIDIPlayer();
</script>
</body>
</html>